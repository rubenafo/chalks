(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chalks = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/**
* @license
* Copyright 2016 Ruben Afonso, rubenaf.com
* This source code is licensed under the Apache license (see LICENSE file)
**/

"use strict";

/**
 * @classdesc This module contains functions to generate layout points
 * @class
 */
class Layout {

  /**
   * Returns a grid of x,y values
   * @param {number} xrows - number of points in x
   * @param {number} yrows - number of points in y
   * @param {number} width - total width
   * @param {number} height - total height
   * @return {array} list of xy values {x:val, y:val}
   */
  static Grid (xrows, yrows, width, height)
  {
    let points = [];
    let xspan = width / xrows;
    let yspan = height / yrows;
    for (let ypoints = 1; ypoints < yrows ; ypoints++)
      for (let xpoints = 1;  xpoints < xrows; xpoints++)
        points.push ({x: xpoints * xspan, y: ypoints * yspan});
    return points;
  }

  /**
  *  Returns a Spiral of points centered at x,y
  * @param {number} points - number of points
  * @param {number} x - initial x coord
  * @param {number} y - initial y
  * @param {number} radius - radio
  * @param {number} coils - number of coils
  * @param {number} chord - chord value
  * @return {array} list of xy values {x:val, y:val}
  */
  static Spiral (params)
  {
    let points = [];
    let centerX = params.x,
        centerY = params.y,
        radius = params.radius,
        coils = params.coils,
        chord = params.chord,
        maxPoints = params.points;
    let rotation = 2 * Math.PI;
    let thetaMax = coils * 2 * Math.PI;
    let awayStep = radius / thetaMax;
    let theta = chord/awayStep;
    for (let i = 0; i < maxPoints; i++) {
      if (theta > thetaMax)
        break;
      let away = awayStep * theta;
      let around = theta + rotation;
      let x = centerX + Math.cos ( around ) * away;
      let y = centerY + Math.sin ( around ) * away;
      theta += chord / away;
      points.push({x: x, y: y, r: theta});
    }
    return points;
  }

  /**
   * Returns the intersecting points after dividing the input area in three sections,
   * following the principles of the Rule Of Thirds.
   * @param {number} x0 - top leftmost x coord
   * @param {number} y0 - top leftmost y coord
   * @param {number} width - width of the area
   * @param {number} length - length of the area
   * @return {array} list containg the four {x,y} points of the intersections
   */
  static RuleOfThirds (x0, y0, width, height) {
    let rulePoints = [];
    let thirdWidth = width / 3;
    let thirdHeight = height / 3;
    rulePoints.push ({x: thirdWidth + x0, y: thirdHeight + y0});
    rulePoints.push ({x: thirdWidth * 2 + x0, y: thirdHeight + y0});
    rulePoints.push ({x: thirdWidth * 2 + x0, y: thirdHeight * 2 + y0});
    rulePoints.push ({x: thirdWidth + x0, y: thirdHeight * 2 + y0});
    return rulePoints;
  }

  /**
   * Returns a list of points along x-axis
   * @param {object} origin      - xy coords to start from
   * @param {number} interColumn - space between columns
   * @param {number} width       - max width
   * @return {object} a list of xy points
   */
  static Cols (origin, interColumn, width) {
    let points = [];
    for (let i = origin.x; i < width; i += interColumn) {
      points.push({x:i, y:origin.y});
    }
    return points;
  }

  /**
   * Returns a list of points along y-axis
   * @param {object} origin   - xy coords to start from
   * @param {number} interRow - space between rows
   * @param {number} height   - max height
   * @return {object} a list of xy points
   */
  static Rows (origin, interRow, height) {
    let points = [];
    for (let i = origin.y; i < height; i += interRow) {
      points.push({x: origin.x, y: i});
    }
    return points;
  }

  /**
   * Returns a list of objects as masonry blocks
   * @param {number} width     - width of the masonry
   * @param {number} height    - height of the masonry
   * @param {string} configStr - ops string with the masonry layout
   * @return {object} a list of bricks with the x,y starting point, width and height of the brick, respectively
   */
  static Masonry (width, height, configStr) {
    return new Masonry (width, height, configStr);
  }

}; // end Layout

module.exports.Layout = Layout;

},{}],2:[function(require,module,exports){
/**
 * @license
 * Copyright 2018 Ruben Afonso, rubenaf.com
 * This source code is licensed under the Apache license (see LICENSE file)
 **/

"use strict";

class Parametrics {

  /**
   * Returns the points generated by a Butterfly curve
   * @param {object} origin - xymap with coordinates
   * @param {number} scale  - value to scale the points
   * @param {number} loops  - number of loops to iterate
   * @param {number} lambda - lambda parameter of the curve
   */
  static butterflyCurve(origin, scale, loops, lambda) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let t = 0.0; t < upperLimit; t += stepSize) {
      let e = (Math.exp(Math.cos(t)) - 2 * Math.cos(lambda * t) - Math.pow(Math.sin(t / 12), 5));
      let x = Math.sin(t) * e;
      let y = Math.cos(t) * e;
      points.push({
        x: x * scale + origin.x,
        y: y * scale + origin.y
      });
    }
    return points;
  }

  /**
   * Returns the points generated by a Hypocycloid curve
   * @param {object} origin - xymap with starting coordinates
   * @param {number} r      - minor circle radio
   * @param {number} R      - major circle radio
   * @param {number} loops  - number of loops to iterate
   */
  static hypocycloid(origin, scale, loops, r, R) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = (R - r) * Math.cos(th) + r * Math.cos(((R - r) / r) * th);
      let y = (R - r) * Math.sin(th) - r * Math.sin(((R - r) / r) * th);
      points.push({ x: x * scale + origin.x, y: y * scale + origin.y });
    }
    return points;
  }

  /**
   * Returns the points generated by a Rose curve.
   * The k parameter can be expressed as (n/d), being both integer values
   * @param {object} origin - xymap with starting coordinates
   * @param {number} k      - k factor of the Rose curve (n/d)
   * @param {number} loops  - number of loops to iterate
   */
  static rose(origin, scale, loops, k) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = Math.cos(k * th) * Math.cos(th);
      let y = Math.cos(k * th) * Math.sin(th);
      points.push({ x: x, y: y });
    }
    return points;
  }

  /**
   * Returns the points from the Rossler attractor
   * @param {object} origin - xy coordinates to center the attractor
   * @param {number} scale - scale factor
   * @param {number} loops - number of iterations
   * @param {number} a a value
   * @param {number} b b value
   * @param {number} c c value
   * @param {number} h h value
   * @return a list of xy points
   *
   *  Rossler Attractor code.
   *  http://paulbourke.net/fractals/rossler/
   */
  static rossler(origin, scale, loops, a, b, c, h) {
    function rosslerPoint(x, y, z, a, b, c) {
      let dx = -(y + z);
      let dy = x + a * y;
      let dz = b + z * (x - c);
      return {
        x: dx,
        y: dy,
        z: dz
      };
    };
    let center = {
      x: origin.x,
      y: origin.y
    }; // center in the screen
    let x = 0.1,
      y = 0.1,
      z = 0.1;
    let tmpx = 0,
      tmpy = 0,
      tmpz = 0;
    let points = [];
    for (let i = 0; i < loops; i++) {
      let dt = rosslerPoint(x, y, z, a, b, c);
      tmpx = x + h * dt.x;
      tmpy = y + h * dt.y;
      tmpz = z + h * dt.z;
      //if (Math.abs(tmpx*20 - x*20) > 5 || Math.abs(tmpy*20 - y*20) > 5)
      points.push({
        x: tmpx * scale + center.x,
        y: tmpy * scale + center.y,
        z: tmpz
      });
      x = tmpx;
      y = tmpy;
      z = tmpz;
    }
    return points;
  }

  /**
   * Returns the Lorent attractor points
   * @param {object} origin - xy coordinates
   * @param {number} scale - scale factor
   * @param {number} loops - iterations
   * @param {number} z - value
   * @param {number} a - value
   * @param {number} b - value
   * @param {number} c - value
   * @param {number} h - value
   * @return a list of xypoints
  
    Lorentz Attractor code.
    http://www.algosome.com/articles/lorenz-attractor-programming-code.html
  */
 static lorentz(origin, scale, loops, x, y, z, a, b, c, h) {
    function lorentzPoint(x, y, z, a, b, c) {
      let dx = a * (y - x);
      let dy = x * (b - z) - y;
      let dz = x * y - c * z;
      return {
        x: dx,
        y: dy,
        z: dz
      };
    };

    //var x = 0.1, y = 0.1, z = 0.1;
    let tmpx = 0,
      tmpy = 0,
      tmpz = 0;
    let points = [];
    for (let i = 0; i < loops; i++) {
      let dt = lorentzPoint(x, y, z, a, b, c);
      tmpx = x + h * dt.x;
      tmpy = y + h * dt.y;
      tmpz = z + h * dt.z;
      points.push({
        x: tmpx * scale + origin.x,
        y: tmpy * scale + origin.y,
        z: tmpz
      });
      x = tmpx;
      y = tmpy;
      z = tmpz;
    }
    return points;
  }

  /**
   * Returns the points from an attractor
   * http://struct.cc/blog/2011/08/15/strange-attractors/
   * @param {number} numPoints number of points to generate
   * @param {string} entryString initial configuration string
   * @return a list of xy points
   */
  static attractor(origin, loops, entryString) {
    // Fractal pattern and coefficients.
    let a = [];
    let points = [];

    // Parameters.
    let x = 0.1,
      y = 0.1;
    let r = 360 % entryString.length;

    // Initialize coefficients.
    for (let i = 0; i < entryString.length; i++) {
      a[i] = (entryString.charCodeAt(i) - 65 - 12) / 10;
    }
    points.push({
      x: origin.x + 50 * Math.cos(r),
      y: origin.y + 58 * Math.sin(r),
      r: 0
    });
    for (let i = 0; i < loops; i++) {
      let nx = a[0] + a[1] * x + a[2] * x * x +
        a[3] * x * y + a[4] * y + a[5] * y * y;
      let ny = a[6] + a[7] * x + a[8] * x * x +
        a[9] * x * y + a[10] * y + a[11] * y * y;
      let xvalue = (origin.x) * nx + origin.x;
      let yvalue = (origin.y) * ny + origin.y;
      //let previousPoint = res[res.length-1];
      points.push({
        x: Math.abs(xvalue),
        y: Math.abs(yvalue)
      });
      x = nx;
      y = ny;
      //r: Functions.calculateAngle (previousPoint, {x:xvalue, y:yvalue})});
    }
    return points;
  }

  /*a = -2.24, b = 0.43, c = -0.65, d = -2.43
    a = 2.01, b = -2.53, c = 1.61, d = -0.33
    a = -2, b = -2, c = -1.2, d = 2
    a = 2.01, b = -2.53, c = 1.61, d = -0.33
    a = -2, b = -2, c = -1.2, d = 2
  */
 static dejon(origin, a, b, c, d, scale = 100, loops = 10) {
    let points = []
    let xt = 1, yt = 1
    for (let i = 0; i < loops; i++) {
      let nextx = (Math.sin(a * yt) - Math.cos(b * xt))
      let nexty = (Math.sin(c * xt) - Math.cos(d * yt))
      points.push({ x: scale * xt + origin[0] + scale, y: scale * yt + origin[1] - scale })
      xt = nextx
      yt = nexty
    }
    return points
  }
}

module.exports = Parametrics
},{}],3:[function(require,module,exports){

"use strict"

class Points {

    static subd (points, level=1) {
        let result = []
        for (let i = 1; i < points.length; i++) {
            result.push (points[i-1], 
                        {x:(points[i-1].x + points[i].x)/2, y:(points[i-1].y + points[i].y)/2})
        }
        result.push(points[points.length-1])
        return result
    }

    static rects (points, height) {
        for (let i = 0; i < points.length; i++) {
            let length = Math.sqrt(points[i].x * points[i].x + points[i].y * points[i].y)
        }
    }

    static rslice (points, minSize, maxSize) {
        let start = Math.round(random() * points.length)
        let end = start + Math.round((maxSize - minSize) * random() + minSize)
        return points.slice(start, end)
    }
}

module.exports = Points
},{}],4:[function(require,module,exports){

let attractors = require("./Parametrics")
let layout = require("./Layout")
let points = require("./Points")

class chalks {

  constructor(params) {
    this.canvas = createCanvas(params.width, params.height)
    background(params.background);
    if (params.seed)
      randomSeed(params.seed)
    else {
      let seed = (Math.random()*10000).toString().substr(5,11)
      console.log ("Using seed: " + seed)
      randomSeed(seed)
    }
    this.startTime = Date.now()
    this.attractors = attractors
    this.layout = layout
    this.Points = points
  }

  addElem(f, attrs) {
    let strokeAttr = attrs["stroke"]
    let alphaAttr = attrs["alpha"]
    let strokeWeightAttr = attrs["strokeWidth"]
    let noFillAttr = attrs["noFill"]
    if (strokeWeightAttr)
      strokeWeight(strokeWeightAttr)
    if (typeof (strokeAttr) === "string")
      strokeAttr = color(strokeAttr)
    if (typeof (strokeAttr) === "object" && alphaAttr)
      strokeAttr.setAlpha(alphaAttr)
    if (noFillAttr !== "undefined" && noFillAttr) {
      noFill();
    }
    stroke(strokeAttr)
    f()
  }

  rect(ats) { return function () { rect(ats.x, ats.y, ats.width, ats.height) } }

  line(p0, p1) { return function () { line(p0.x, p0.y, p1.x, p1.y) } }

  point(ats) { return function () { point(ats.x, ats.y) } }


  shape(pts, closed = true) {
    return function () {
      beginShape()
      pts.forEach(p => vertex(p.x, p.y))
      closed ? endShape(CLOSE) : endShape()
    }
  }

  curveVertex(pts) {
    return function () {
      beginShape()
      curveVertex(pts[0].x, pts[0].y)
      pts.forEach(p => curveVertex(p.x, p.y))
      curveVertex(pts[pts.length - 1].x, pts[pts.length - 1].y)
      endShape()
    }
  }

  stopAt(countLimit, saveToFile) {
    if (frameCount == countLimit) {
      let time = (Date.now() - this.startTime) / 1000
      console.log("Execution stopped at " + countLimit + " iterations (" + time + " secs)")
      if (saveToFile) {
        save(this.canvas, saveToFile, "png")
        console.log("File saved to ", saveToFile)
      }
      noLoop()
    }
  }
}

p5.prototype.rint = function (lower, upper) {
  return Math.round(random(lower, upper))
}

p5.prototype.rnd = function (start, end) {
  if (Array.isArray(start)) {
    return start[rint(0, start.length - 1)]
  }
  let val = 0
  if (start && end)
    val = random(start, end)
  else if (start !== undefined)
    val = random(0, start)
  else val = random(0, 1)
  return val
}

p5.prototype.rscale = function (scaleStart, scaleEnd, inputStart, inputEnd, value) {
  let distance = scaleEnd - scaleStart
  let step = (value - inputStart) / (inputEnd - inputStart)
  let returnVal = scaleStart + (distance * step)
  returnVal = Math.max(returnVal, scaleStart)
  returnVal = Math.min(returnVal, scaleEnd)
  return returnVal
}

module.exports = chalks
},{"./Layout":1,"./Parametrics":2,"./Points":3}]},{},[4])(4)
});
