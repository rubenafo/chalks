(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Chalks = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var n=.2126,r=.7152,t=.0722,e=1/12.92;function u(n){return Math.pow((n+.055)/1.055,2.4)}function a(a){var s=a[0]/255,i=a[1]/255,o=a[2]/255,c=s<=.03928?s*e:u(s),p=i<=.03928?i*e:u(i),f=o<=.03928?o*e:u(o);return c*n+p*r+f*t}function s(n){var r=255;8===(n=n.replace(/^#/,"")).length&&(r=parseInt(n.slice(6,8),16),n=n.substring(0,6)),4===n.length&&(r=parseInt(n.slice(3,4).repeat(2),16),n=n.substring(0,3)),3===n.length&&(n=n[0]+n[0]+n[1]+n[1]+n[2]+n[2]);var t=parseInt(n,16);return[t>>16,t>>8&255,255&t,r]}function i(n,r){return(Math.max(n,r)+.05)/(Math.min(n,r)+.05)}function o(n,r){return i(a(n),a(r))}exports.luminance=i,exports.rgb=o,exports.hex=function(n,r){return o(s(n),s(r))},exports.score=function(n){return n>=7?"AAA":n>=4.5?"AA":""};


},{}],2:[function(require,module,exports){

class Brush {


}

module.exports = Brush

},{}],3:[function(require,module,exports){
/**
* @license
* Copyright 2016 Ruben Afonso, rubenaf.com
* This source code is licensed under the Apache license (see LICENSE file)
**/

"use strict";

/**
 * @classdesc This module contains functions to generate layout points
 * @class
 */
class Layout {

  /**
   * Returns a grid of x,y values
   * @param {number} xrows - number of points in x
   * @param {number} yrows - number of points in y
   * @param {number} width - total width
   * @param {number} height - total height
   * @return {array} list of xy values {x:val, y:val}
   */
  static Grid (xrows, yrows, width, height)
  {
    let points = [];
    let xspan = width / xrows;
    let yspan = height / yrows;
    for (let ypoints = 1; ypoints < yrows ; ypoints++)
      for (let xpoints = 1;  xpoints < xrows; xpoints++)
        points.push ({x: xpoints * xspan, y: ypoints * yspan});
    return points;
  }

  /**
  *  Returns a Spiral of points centered at x,y
  * @param {number} points - number of points
  * @param {number} x - initial x coord
  * @param {number} y - initial y
  * @param {number} radius - radio
  * @param {number} coils - number of coils
  * @param {number} chord - chord value
  * @return {array} list of xy values {x:val, y:val}
  */
  static spiral (params)
  {
    let points = [];
    let centerX = params.x,
        centerY = params.y,
        radius = params.radius,
        coils = params.coils,
        chord = params.chord,
        maxPoints = params.points;
    let rotation = 2 * Math.PI;
    let thetaMax = coils * 2 * Math.PI;
    let awayStep = radius / thetaMax;
    let theta = chord/awayStep;
    for (let i = 0; i < maxPoints; i++) {
      if (theta > thetaMax)
        break;
      let away = awayStep * theta;
      let around = theta + rotation;
      let x = centerX + Math.cos ( around ) * away;
      let y = centerY + Math.sin ( around ) * away;
      theta += chord / away;
      points.push({x: x, y: y, r: theta});
    }
    return points;
  }

  /**
   * Returns the intersecting points after dividing the input area in three sections,
   * following the principles of the Rule Of Thirds.
   * @param {number} x0 - top leftmost x coord
   * @param {number} y0 - top leftmost y coord
   * @param {number} width - width of the area
   * @param {number} length - length of the area
   * @return {array} list containg the four {x,y} points of the intersections
   */
  static RuleOfThirds (x0, y0, width, height) {
    let rulePoints = [];
    let thirdWidth = width / 3;
    let thirdHeight = height / 3;
    rulePoints.push ({x: thirdWidth + x0, y: thirdHeight + y0});
    rulePoints.push ({x: thirdWidth * 2 + x0, y: thirdHeight + y0});
    rulePoints.push ({x: thirdWidth * 2 + x0, y: thirdHeight * 2 + y0});
    rulePoints.push ({x: thirdWidth + x0, y: thirdHeight * 2 + y0});
    return rulePoints;
  }

  /**
   * Returns a list of points along x-axis
   * @param {object} origin      - xy coords to start from
   * @param {number} interColumn - space between columns
   * @param {number} width       - max width
   * @return {object} a list of xy points
   */
  static cols (origin, interColumn, width) {
    let points = [];
    for (let i = origin.x; i < width; i += interColumn) {
      points.push({x:i, y:origin.y});
    }
    return points;
  }

  /**
   * Returns a list of points along y-axis
   * @param {object} origin   - xy coords to start from
   * @param {number} interRow - space between rows
   * @param {number} height   - max height
   * @return {object} a list of xy points
   */
  static rows (origin={x:0, y:0}, interRow=10, height=100) {
    let points = [];
    for (let i = origin.y; i < height; i += interRow) {
      points.push({x: origin.x, y: i});
    }
    return points;
  }

  /**
   * Returns a list of objects as masonry blocks
   * @param {number} width     - width of the masonry
   * @param {number} height    - height of the masonry
   * @param {string} configStr - ops string with the masonry layout
   * @return {object} a list of bricks with the x,y starting point, width and height of the brick, respectively
   */
  static Masonry (width, height, configStr) {
    return new Masonry (width, height, configStr);
  }

}; // end Layout

module.exports = Layout;

},{}],4:[function(require,module,exports){
/**
 * @license
 * Copyright 2018 Ruben Afonso, rubenaf.com
 * This source code is licensed under the Apache license (see LICENSE file)
 **/

"use strict";

class Parametrics {

  /**
   * Returns the points generated by a Butterfly curve
   * @param {object} origin - xymap with coordinates
   * @param {number} scale  - value to scale the points
   * @param {number} loops  - number of loops to iterate
   * @param {number} lambda - lambda parameter of the curve
   */
  static butterflyCurve(origin, scale, loops, lambda) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let t = 0.0; t < upperLimit; t += stepSize) {
      let e = (Math.exp(Math.cos(t)) - 2 * Math.cos(lambda * t) - Math.pow(Math.sin(t / 12), 5));
      let x = Math.sin(t) * e;
      let y = Math.cos(t) * e;
      points.push({
        x: x * scale + origin.x,
        y: y * scale + origin.y
      });
    }
    return points;
  }

  /**
   * Returns the points generated by a Hypocycloid curve
   * @param {object} origin - xymap with starting coordinates
   * @param {number} r      - minor circle radio
   * @param {number} R      - major circle radio
   * @param {number} loops  - number of loops to iterate
   */
  static hypocycloid(origin, scale, loops, r, R) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = (R - r) * Math.cos(th) + r * Math.cos(((R - r) / r) * th);
      let y = (R - r) * Math.sin(th) - r * Math.sin(((R - r) / r) * th);
      points.push({ x: x * scale + origin.x, y: y * scale + origin.y });
    }
    return points;
  }

  /**
   * Returns the points generated by a Rose curve.
   * The k parameter can be expressed as (n/d), being both integer values
   * @param {object} origin - xymap with starting coordinates
   * @param {number} k      - k factor of the Rose curve (n/d)
   * @param {number} loops  - number of loops to iterate
   */
  static rose(origin, scale, loops, k) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = Math.cos(k * th) * Math.cos(th);
      let y = Math.cos(k * th) * Math.sin(th);
      points.push({ x: x, y: y });
    }
    return points;
  }

  /**
   * Returns the points from the Rossler attractor
   * @param {object} origin - xy coordinates to center the attractor
   * @param {number} scale - scale factor
   * @param {number} loops - number of iterations
   * @param {number} a a value
   * @param {number} b b value
   * @param {number} c c value
   * @param {number} h h value
   * @return a list of xy points
   *
   *  Rossler Attractor code.
   *  http://paulbourke.net/fractals/rossler/
   */
  static rossler(origin, scale, loops, a, b, c, h) {
    function rosslerPoint(x, y, z, a, b, c) {
      let dx = -(y + z);
      let dy = x + a * y;
      let dz = b + z * (x - c);
      return {
        x: dx,
        y: dy,
        z: dz
      };
    };
    let center = {
      x: origin.x,
      y: origin.y
    }; // center in the screen
    let x = 0.1,
      y = 0.1,
      z = 0.1;
    let tmpx = 0,
      tmpy = 0,
      tmpz = 0;
    let points = [];
    for (let i = 0; i < loops; i++) {
      let dt = rosslerPoint(x, y, z, a, b, c);
      tmpx = x + h * dt.x;
      tmpy = y + h * dt.y;
      tmpz = z + h * dt.z;
      //if (Math.abs(tmpx*20 - x*20) > 5 || Math.abs(tmpy*20 - y*20) > 5)
      points.push({
        x: tmpx * scale + center.x,
        y: tmpy * scale + center.y,
        z: tmpz
      });
      x = tmpx;
      y = tmpy;
      z = tmpz;
    }
    return points;
  }

  /**
   * Returns the Lorent attractor points
   * @param {object} origin - xy coordinates
   * @param {number} scale - scale factor
   * @param {number} loops - iterations
   * @param {number} z - value
   * @param {number} a - value
   * @param {number} b - value
   * @param {number} c - value
   * @param {number} h - value
   * @return a list of xypoints
  
    Lorentz Attractor code.
    http://www.algosome.com/articles/lorenz-attractor-programming-code.html
  */
 static lorentz(origin, scale, loops, x, y, z, a, b, c, h) {
    function lorentzPoint(x, y, z, a, b, c) {
      let dx = a * (y - x);
      let dy = x * (b - z) - y;
      let dz = x * y - c * z;
      return {
        x: dx,
        y: dy,
        z: dz
      };
    };

    //var x = 0.1, y = 0.1, z = 0.1;
    let tmpx = 0,
      tmpy = 0,
      tmpz = 0;
    let points = [];
    for (let i = 0; i < loops; i++) {
      let dt = lorentzPoint(x, y, z, a, b, c);
      tmpx = x + h * dt.x;
      tmpy = y + h * dt.y;
      tmpz = z + h * dt.z;
      points.push({
        x: tmpx * scale + origin.x,
        y: tmpy * scale + origin.y,
        z: tmpz
      });
      x = tmpx;
      y = tmpy;
      z = tmpz;
    }
    return points;
  }

  /**
   * Returns the points from an attractor
   * http://struct.cc/blog/2011/08/15/strange-attractors/
   * @param {number} numPoints number of points to generate
   * @param {string} entryString initial configuration string
   * @return a list of xy points
   */
  static attractor(origin, loops, entryString) {
    // Fractal pattern and coefficients.
    let a = [];
    let points = [];

    // Parameters.
    let x = 0.1,
      y = 0.1;
    let r = 360 % entryString.length;

    // Initialize coefficients.
    for (let i = 0; i < entryString.length; i++) {
      a[i] = (entryString.charCodeAt(i) - 65 - 12) / 10;
    }
    points.push({
      x: origin.x + 50 * Math.cos(r),
      y: origin.y + 58 * Math.sin(r),
      r: 0
    });
    for (let i = 0; i < loops; i++) {
      let nx = a[0] + a[1] * x + a[2] * x * x +
        a[3] * x * y + a[4] * y + a[5] * y * y;
      let ny = a[6] + a[7] * x + a[8] * x * x +
        a[9] * x * y + a[10] * y + a[11] * y * y;
      let xvalue = (origin.x) * nx + origin.x;
      let yvalue = (origin.y) * ny + origin.y;
      //let previousPoint = res[res.length-1];
      points.push({
        x: Math.abs(xvalue),
        y: Math.abs(yvalue)
      });
      x = nx;
      y = ny;
      //r: Functions.calculateAngle (previousPoint, {x:xvalue, y:yvalue})});
    }
    return points;
  }

  /*a = -2.24, b = 0.43, c = -0.65, d = -2.43
    a = 2.01, b = -2.53, c = 1.61, d = -0.33
    a = -2, b = -2, c = -1.2, d = 2
    a = 2.01, b = -2.53, c = 1.61, d = -0.33
    a = -2, b = -2, c = -1.2, d = 2
  */
 static dejon(origin, a, b, c, d, scale = 100, loops = 10) {
    let points = []
    let xt = 1, yt = 1
    for (let i = 0; i < loops; i++) {
      let nextx = (Math.sin(a * yt) - Math.cos(b * xt))
      let nexty = (Math.sin(c * xt) - Math.cos(d * yt))
      points.push({ x: scale * xt + origin[0] + scale, y: scale * yt + origin[1] - scale })
      xt = nextx
      yt = nexty
    }
    return points
  }
}

module.exports = Parametrics
},{}],5:[function(require,module,exports){

"use strict"

class Path {

  constructor (scene, style={}) {
    this.style = style
    this.instrs = []
    this.ops = []
    this.parent = scene
    this.parent.children.push(this)
    this.ctx = scene.ctx
  }

  clone(style) {
    let newPath = new Path(this.parent, style || this.style)
    delete(newPath.style.hide)
    newPath.instrs = JSON.parse(JSON.stringify(this.instrs))
    newPath.ops = JSON.parse(JSON.stringify(this.ops))
    return newPath
  }

  m(x,y) {
    let point = typeof(x) === "object" ? x : {x:x, y:y}
    this.instrs.push({instr:"m", p:point}); return this
  }

  l(x,y) {
    let point = typeof(x) === "object" ? x : {x:x, y:y}
    this.instrs.push({instr:"l", p:point}); return this
  }

  bezier(c1, c2, p2) { this.instrs.push({instr:"b", c1:c1, c2:c2, p2:p2}); return this }
  arc(p1, p2, r) { this.instrs.push({instr:"a", p1:p1, p2:p2, r:r}); return this}
  quad(c, p) { this.instrs.push({instr:"q", c:c, p:p}); return this }

  center() {
    let x = 0, y = 0, pts = 0;
    this.instrs.forEach (i => {
      switch(i.instr) {
        case "l" :
          x += i.p.x; y += i.p.y
          pts += 1
          break
        case "q":
          x += i.p.x; y += i.p.y;
          x += i.c.x; y += i.c.y;
          pts += 2
          break;
        case "b":
          x += i.c1.x; y += i.c1.y
          x += i.c2.x; y += i.c2.y
          x += i.p2.x; y += i.p2.y
          pts += 3
          break;
        case "a":
          x += i.p1.x; y += i.p1.y
          x += i.p2.x; y += i.p2.y
          pts += 2
          break;
      }
    })
    if (pts) {
      x = x / (pts)
      y = y / (pts)
    }
    return {x:x, y:y}
  }

  shadow(blur=0, color="black", alpha=1, x=5, y=5) {
    this.ctx.shadowBlur = blur
    this.ctx.shadowColor = color
    this.ctx.shadowOffsetX = x
    this.ctx.shadowOffsetY = y
    this.ctx.shadowAlpha = alpha
    return this
  }

  add(p1,p2) {
    return ({x: p1.x + p2.x, y: p1.y + p2.y})
  }

  moveTo(p0,y) {
    let p = typeof(p0) === "object" ? p0 : {x:p0, y:y}
    let center = this.center()
    let distance = {x: p.x - center.x, y: p.y - center.y}
    this.instrs.forEach ((i,ind) => {
      switch(i.instr) {
        case "m" : case "l" : case "arc":
          this.instrs[ind].p = this.add(i.p, distance)  //this.add(i.p, distance);
          break
        case "q":
          i.p = this.add(i.p, distance);
          i.c = this.add(i.c, distance); break
        case "b":
          i.c1 = this.add(i.c1, distance)
          i.c2 = this.add(i.c2, distance)
          i.p2 = this.add(i.p2, distance); break;
        case "a":
          i.p1 = this.add(i.p1, distance);
          i.p2 = this.add(i.p2, distance); break;
      }
    })
    return this
  }

  rotate(deg, pt) {
    let p = pt || this.center()
    if(p) {
      this.ops.push({op:"translate", values:[p.x, p.y]})
      this.ops.push({op:"rotate", values:[deg * Math.PI/180]})
      this.ops.push({op:"translate", values:[-p.x, -p.y]})
    }
    else{
      this.ops.push({op:"rotate", values:[deg * Math.PI/180]})
    }
    return this
  }

  draw () {
    this.ctx.save()
    this.ops.forEach (op => {
      if (op.op === "translate") {
        this.ctx.translate(op.values[0], op.values[1])
      }
      else { // rotate
        this.ctx.rotate(op.values[0])
      }
    })
    this.ctx.beginPath()
    this.instrs.forEach (instr => {
       switch (instr.instr) {
         case "m": this.ctx.moveTo(instr.p.x, instr.p.y); break
         case "l": this.ctx.lineTo(instr.p.x, instr.p.y); break
         case "b": this.ctx.bezierCurveTo(instr.c1.x, instr.c1.y,
                                               instr.c2.x, instr.c2.y,
                                               instr.p2.x, instr.p2.y); break
         case "a": this.ctx.arcTo(instr.p1.x, instr.p1.y, instr.p2.x, instr.p2.y, instr.r); break
         case "q": this.ctx.quadraticCurveTo(instr.c.x, instr.c.y, instr.p.x, instr.p.y); break
         case "arc": this.ctx.arc(instr.p.x, instr.p.y, instr.r, instr.sa, instr.ea, instr.cw); break
       }
    })
    this.applyStyle()
   }

   applyStyle() {
     if (this.style.fill) {
       this.ctx.globalAlpha = this.style.alpha || 1
       this.ctx.fillStyle = this.style.fill
       this.ctx.fill()
     }
     if (this.style.stroke) {
       this.ctx.globalAlpha = this.style.strokeAlpha || this.style.alpha || 1
       this.ctx.strokeStyle = this.style.stroke
       this.ctx.lineWidth=this.style.strokeWidth || 1
       this.ctx.stroke()
     }
     if (this.style.shadow) {
       this.ctx.shadowColor = this.style.shadow
       this.ctx.shadowOffsetX = 10
       this.ctx.shadowOffsetY = 10
       //this.ctx.shadowBlur = this.style.shadowBlur;
     }
     if (this.style.filter) {
       this.style.filter.forEach(f => this.ctx.filter(f))
     }
     this.ctx.lineCap = this.style.lineCap || "butt"
     this.ctx.restore()
     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
   }

   fromPoints(m, n, height=10, padding=0) {
     let vector = {x: n.x - m.x, y:n.y - m.y}
     let length = Math.sqrt(vector.x * vector.x + vector.y * vector.y)
     let p0 = {x:m.x -padding, y:m.y - height/2}
     let p1 = {x:m.x + length + padding, y:m.y - height/2}
     let p2 = {x:m.x + length + padding, y:m.y + height/2}
     let p3 = {x:m.x- padding, y:m.y + height/2}
     this.m(p0).l(p1).l(p2).l(p3).l(p0)
     let xdiff = n.x - m.x
     let ydiff = n.y - m.y
     let deg = Math.atan2(ydiff, xdiff) * (180 / Math.PI)
     this.rotate(deg, m)
     return this
   }

   circle(p, r=10, sa=0, ea=Math.PI * 2, cw=true) {
     this.instrs.push({instr:"arc", p:{x:0,y:0}, r:r, sa:sa, ea:ea, cw:cw})
     this.moveTo(p)
     return this
   }

   rect(p0, w, h) {
     return this.fromPoints({x:p0.x, y:p0.y+h/2}, {x:p0.x+w, y:p0.y+h/2}, h)
   }

   line(p0, p1) {
     this.ctx.beginPath()
     this.m(p0).l(p1)
     this.applyStyle()
     return this
   }
}

module.exports = Path

},{}],6:[function(require,module,exports){
/**
* @license
* Copyright 2018 Ruben Afonso, rubenaf.com
* This source code is licensed under the Apache license (see LICENSE file)
**/

"use strict";

//let D3 = require ("d3")

const E = Math.E;
const PI = Math.PI;
const PI_2 = PI / 2;

class Rnd {

  constructor (seed) {
    if (typeof(seed) === "string") {
      var i = seed.length;
      this.seed = 0;
      while (i--) {
        this.seed += seed.charCodeAt(i);
      }
    }
    else
    this.seed = seed !== undefined ? seed : Math.random();
  }

  setSeed (seed) {
    if (seed)
    this.seed = seed;
  }

  pick (...elems) {
    let list = (elems && Array.isArray(elems[0])) ? elems[0] : elems
    let numElems = list.length;
    if (!numElems)
      return null;
    var index = Math.floor(this.random(numElems));
    return list[index];
  }

  //colorIn (scale, start, end, initColor, endColor) {
  //  return D3.scaleLinear().domain([1, end]).range([initColor, endColor])(scale);
  //}

  static genId () {
    var id = "id-";
    for (let i = 0; i < 10; i++)
    {
      id += String.fromCharCode(97 + Math.floor(Math.random() * 26))
    }
    return id;
  }

  random (lower, upper) {
    var x = Math.sin(this.seed++) * 10000;
    if (upper === undefined) {
      if (lower === undefined) { // both undefined, assume (0,1)
        return x - Math.floor(x);
      }
      else { // we only have lower, assume (0,lower)
        return (x - Math.floor(x)) * lower;
      }
    }
    else {
      return lower + ((x - Math.floor(x)) * (upper-lower))
    }
  }

  int (lower, upper) {
    return Math.round(this.random(lower, upper));
  }

  arcsine (min, max) {
    var q = Math.sin(PI_2 * this.uniform(0, 1));

    return min + (max - min) * q * q;
  };

  beta (v, w, min, max) {
    if (v < w) {
      return max - (max - min) * this.beta(w, v, 0, 1);
    }
    var y1 = this.gamma(0, 1, v),
    y2 = this.gamma(0, 1, w);

    return min + (max - min) * y1 / (y1 + y2);
  };

  cauchy (a, b) {
    return a + b * Math.tan(PI * this.uniform(-0.5, 0.5))
  };

  chiSquare (df) {
    return this.gamma(0, 2, 0.5 * df);
  };

  cosine (min, max) {
    var a = 0.5 * (min + max),
    b = (max - min) / PI;

    return a + b * Math.asin(this.uniform(-1, 1));
  };

  doubleLog (min, max) {
    var a = 0.5 * (min + max),
    b = 0.5 * (max - min);
    if (this.bernoulli(0.5) === 0) {
      b = -b;
    }

    return a + b * this.uniform(0, 1) * this.uniform(0, 1);
  };

  erlang (b, c) {
    var prod = 1.0;
    var i = 1;

    for (i = 1; i < c; i++) {
      prod *= this.uniform(0, 1);
    }

    return -b * Math.log(prod);
  };

  exponential (a, b) {
    return a - b * Math.log(this.uniform(0, 1));
  };

  extremeValue (a, b) {
    return a + b * Math.log(-Math.log(this.uniform(0, 1)));
  };

  fRatio (v, w) {
    return (this.chiSquare(v) / v) / (this.chiSquare(w) / w);
  };

  gamma (a, b, c) {
    var A = 1 / Math.sqrt(2 * c - 1),
    B = c - Math.log(4),
    Q = c + 1 / A,
    T = 4.5,
    D = 1 + Math.log(T),
    C = 1 + c / E;

    if (c < 1) {
      while (true) {
        var p = C * this.uniform(0, 1);
        if (p > 1) {
          var y = -Math.log((C - p) / c);
          if (this.uniform(0, 1) <= Math.pow(y, c - 1)) {
            return a + b * y;
          }
        } else {
          var y = Math.pow(p, 1 / c);
          if (this.uniform(0, 1) <= Math.exp(-y)) {
            return a + b * y;
          }
        }
      }
    } else if (c == 1.0) {
      return this.exponential(a, b);
    } else {
      while (true) {
        var p1 = this.uniform(0, 1),
        p2 = this.uniform(0, 1),
        v = A * Math.log(p1 / (1 - p1)),
        y = c * Math.exp(v),
        z = p1 * p1 * p2,
        w = B + Q * v - y;
        if (w + D - T * z > 0 || w >= Math.log(z)) {
          return a + b * y
        }
      }
    }
  };

  laplace (a, b) {
    if (this.bernoulli(0.5) == 1) {
      return a + b * Math.log(this.uniform(0, 1));
    } else {
      return a - b * Math.log(this.uniform(0, 1));
    }
  };

  logarithmic (min, max) {
    var a = min,
    b = max - min;

    return a + b * this.uniform(0, 1) * this.uniform(0, 1);
  };

  logistic (a, b) {
    return a - b * Math.log(1 / this.uniform(0, 1) - 1);
  };

  lognormal (a, mu, sigma) {
    return a + Math.exp(this.normal(mu, sigma));
  };

  normal (mu, sigma) {
    var p , p1, p2;
    do {
      p1 = this.uniform(-1, 1);
      p2 = this.uniform(-1, 1);
      p = p1 * p1 + p2 * p2;
    } while (p >= 1);

    return mu + sigma * p1 * Math.sqrt(-2 * Math.log(p) / p);
  };

  parabolic (min ,max) {
    var parabola = function (x, min, max) {
      if (x < min || x > max) {
        return 0.0;
      }

      var a = 0.5 * (min + max),
      b = 0.5 * (max - min),
      yMax = 3 / (4 * b);

      return yMax * (1 - (x - a) * (x - a) / (b * b));
    };

    var a = 0.5 * (min  + max),
    yMax = parabola(a, min + max);

    return this.userSpecified(parabola, min ,max, 0, yMax);
  };

  pareto (c) {
    return Math.pow(this.uniform(0, 1), -1 / c);
  };

  pearson5 (b, c) {
    return 1 / this.gamma(0, 1 / b, c);
  };

  pearson6 (b, v, w) {
    return this.gamma(0, b, v) / this.gamma(0, b, w);
  };

  power (c) {
    return Math.pow(this.uniform(0, 1), 1 / c);
  };

  rayleigh (a, b) {
    return a + b * Math.sqrt(-Math.log(this.uniform(0, 1)));
  };

  studentT (df) {
    return this.normal(0, 1) / Math.sqrt(this.chiSquare(df) / df);
  };

  triangular (min, max, c) {
    var p = this.uniform(0, 1),
    q = 1 - p;
    if (p <= (c - min) / (max - min)) {
      return min + Math.sqrt((max - min) * (c - min) * p);
    } else {
      return max - Math.sqrt((max - min) * (max - c) * q);
    }
  };

  uniform (min, max) {
    var init = this.seed !== undefined? this.random() : Math.random();
    return min + (max - min) * init;
  };

  userSpecified (usf, xMin, xMax, yMin, yMax) {
    var x,
    y,
    areaMax = (xMax - xMin) * (yMax - yMin);

    do {
      x = this.uniform(0, areaMax) / (yMax - yMin) + xMin;
      y = this.uniform(yMin, yMax);
    } while (y > usf(x, xMin, xMax));
    return x;
  };

  weibull (a, b, c) {
    return a + b * Math.pow(-Math.log(this.uniform(0, 1)), 1 / c);
  };

  bernoulli (p) {
    return this.uniform(0, 1) < p ? 0 : 1;
  };

  binomial (n, p) {
    var sum = 0;
    for (var i = 0; i < n; i++) {
      sum += this.bernoulli(p);
    }

    return sum;
  };

  geometric (p) {
    return Math.floor(Math.log(this.uniform(0, 1)) / Math.log(1 - p));
  };

  hypergeometric (n, N, K) {
    var count = 0;
    for (var i = 0; i < n; i++, N--) {
      var p = K / N;
      if (this.bernoulli(p)) {
        count++;
        K--;
      }
    }

    return count;
  };

  negativeBinomial (s, p) {
    var sum = 0;
    for (var i = 0; i < s; i++) {
      sum += this.geometric(p);
    }

    return sum;
  };

  pascal (s, p) {
    return this.negativeBinomial(s, p) + s;
  };

  poisson (mu) {
    var b = 1;
    for (var i = 0; b >= Math.exp(-mu); i++) {
      b *= this.uniform(0, 1);
    }

    return i - 1;
  };

  uniformDiscrete (i, j) {
    return i + Math.floor((j - i + 1) * this.uniform(0, 1));
  };
};

module.exports.Rnd = Rnd;

},{}],7:[function(require,module,exports){
//let fs = require ("fs")
//let path = require ("path")
//let Canvas = require('canvas')
//let Image = Canvas.Image

let Brush = require("./Brush")
let Layout = require("./Layout")
//let Rnd = require ("./Rnd").Rnd
let Path = require("./Path")
let Rnd = require("./Rnd").Rnd
let Parametrics = require("./Parametrics")
let wcag = require("wcag-contrast")

// Provide debug messages in the console
function debug(str) {
  console.log("Chalks:", str)
}

class Scene {
  constructor(params, style = {}) {
    this.Brush = Brush
    this.scale = params.scale || 1
    this.width = params.width * this.scale || 1000
    this.height = params.height * this.scale || 1000
    this.canvas = document.getElementById('canvas');
    canvas.width = this.width
    canvas.height = this.height
    this.ctx = this.canvas.getContext('2d')
    this.start = Date.now()
    if (params.seed) {
      debug("using seed=" + params.seed)
      this.rnd = new Rnd(params.seed)
    } else {
      let seed = (Math.random() * 10000).toString().substr(5, 8)
      debug("using seed: " + seed)
      this.rnd = new Rnd(seed)
    }
    this.children = []
    this.drawBackground(this.width, this.height, style)
  }

  drawBackground(width, height, style) {
    this.ctx.fillStyle = style.fill || "white"
    this.ctx.fillRect(0, 0, width * this.scale, height * this.scale)
    this.ctx.fillStyle = "black"
  }

  setStyle(style) {
    this.drawBackground(this.width, this.height, style)
  }

  rint(lower, upper) {
    return this.rnd.int(lower, upper)
  }
  rand(lower, upper) {
    return this.rnd.random(lower, upper)
  }
  pick(list, ...elems) {
    return this.rnd.pick(list, ...elems)
  }

  path(style) {
    return new Path(this, style)
  }

  // Linear gradient: p0, p1, stops as [[num, color]]
  lgrad(p0, p1, colors) {
    let grad = this.ctx.createLinearGradient(0, 0, 1000, 1000)
    colors.forEach(c => {
      grad.addColorStop(c[0], c[1])
    })
    return grad
  }

  // Radial gradient
  rgrad(p0, r0, p1, r1, colors) {
    let grad = this.ctx.createRadialGradient(p0.x, p0.y, r0, p1.x, p1.y, r1)
    colors.forEach(c => {
      grad.addColorStop(c[0], c[1])
    })
    return grad
  }

  draw() {
    this.children.filter(c => !c.style.hide).forEach(c => c.draw())
    debug("ended" + " (" + (Date.now() - this.start) / 1000 + " secs)")
  }

  //saveTo(fileName) {
  //  this.canvas.createPNGStream().pipe(fs.createWriteStream(fileName))
  //    console.log("Save to " + fileName + " (" + (Date.now() - this.start) / 1000 + " secs)")
  //}
}

module.exports = {
  Scene,
  Layout,
  Path,
  Parametrics
}

},{"./Brush":2,"./Layout":3,"./Parametrics":4,"./Path":5,"./Rnd":6,"wcag-contrast":1}]},{},[7])(7)
});
