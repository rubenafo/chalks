(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.chalks = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){

class Brush {


}

module.exports = Brush

},{}],2:[function(require,module,exports){
/**
* @license
* Copyright 2016 Ruben Afonso, rubenaf.com
* This source code is licensed under the Apache license (see LICENSE file)
**/

"use strict";

/**
 * @classdesc This module contains functions to generate layout points
 * @class
 */
class Layout {

  /**
   * Returns a grid of x,y values
   * @param {number} xrows - number of points in x
   * @param {number} yrows - number of points in y
   * @param {number} width - total width
   * @param {number} height - total height
   * @return {array} list of xy values {x:val, y:val}
   */
  static Grid (xrows, yrows, width, height)
  {
    let points = [];
    let xspan = width / xrows;
    let yspan = height / yrows;
    for (let ypoints = 1; ypoints < yrows ; ypoints++)
      for (let xpoints = 1;  xpoints < xrows; xpoints++)
        points.push ({x: xpoints * xspan, y: ypoints * yspan});
    return points;
  }

  /**
  *  Returns a Spiral of points centered at x,y
  * @param {number} points - number of points
  * @param {number} x - initial x coord
  * @param {number} y - initial y
  * @param {number} radius - radio
  * @param {number} coils - number of coils
  * @param {number} chord - chord value
  * @return {array} list of xy values {x:val, y:val}
  */
  static spiral (params)
  {
    let points = [];
    let centerX = params.x,
        centerY = params.y,
        radius = params.radius,
        coils = params.coils,
        chord = params.chord,
        maxPoints = params.points;
    let rotation = 2 * Math.PI;
    let thetaMax = coils * 2 * Math.PI;
    let awayStep = radius / thetaMax;
    let theta = chord/awayStep;
    for (let i = 0; i < maxPoints; i++) {
      if (theta > thetaMax)
        break;
      let away = awayStep * theta;
      let around = theta + rotation;
      let x = centerX + Math.cos ( around ) * away;
      let y = centerY + Math.sin ( around ) * away;
      theta += chord / away;
      points.push({x: x, y: y, r: theta});
    }
    return points;
  }

  /**
   * Returns the intersecting points after dividing the input area in three sections,
   * following the principles of the Rule Of Thirds.
   * @param {number} x0 - top leftmost x coord
   * @param {number} y0 - top leftmost y coord
   * @param {number} width - width of the area
   * @param {number} length - length of the area
   * @return {array} list containg the four {x,y} points of the intersections
   */
  static RuleOfThirds (x0, y0, width, height) {
    let rulePoints = [];
    let thirdWidth = width / 3;
    let thirdHeight = height / 3;
    rulePoints.push ({x: thirdWidth + x0, y: thirdHeight + y0});
    rulePoints.push ({x: thirdWidth * 2 + x0, y: thirdHeight + y0});
    rulePoints.push ({x: thirdWidth * 2 + x0, y: thirdHeight * 2 + y0});
    rulePoints.push ({x: thirdWidth + x0, y: thirdHeight * 2 + y0});
    return rulePoints;
  }

  /**
   * Returns a list of points along x-axis
   * @param {object} origin      - xy coords to start from
   * @param {number} interColumn - space between columns
   * @param {number} width       - max width
   * @return {object} a list of xy points
   */
  static cols (origin, interColumn, width) {
    let points = [];
    for (let i = origin.x; i < width; i += interColumn) {
      points.push({x:i, y:origin.y});
    }
    return points;
  }

  /**
   * Returns a list of points along y-axis
   * @param {object} origin   - xy coords to start from
   * @param {number} interRow - space between rows
   * @param {number} height   - max height
   * @return {object} a list of xy points
   */
  static rows (origin={x:0, y:0}, interRow=10, height=100) {
    let points = [];
    for (let i = origin.y; i < height; i += interRow) {
      points.push({x: origin.x, y: i});
    }
    return points;
  }

  /**
   * Returns a list of objects as masonry blocks
   * @param {number} width     - width of the masonry
   * @param {number} height    - height of the masonry
   * @param {string} configStr - ops string with the masonry layout
   * @return {object} a list of bricks with the x,y starting point, width and height of the brick, respectively
   */
  static Masonry (width, height, configStr) {
    return new Masonry (width, height, configStr);
  }

}; // end Layout

module.exports = Layout;

},{}],3:[function(require,module,exports){
/**
 * @license
 * Copyright 2018 Ruben Afonso, rubenaf.com
 * This source code is licensed under the Apache license (see LICENSE file)
 **/

"use strict";

class Parametrics {

  /**
   * Returns the points generated by a Butterfly curve
   * @param {object} origin - xymap with coordinates
   * @param {number} scale  - value to scale the points
   * @param {number} loops  - number of loops to iterate
   * @param {number} lambda - lambda parameter of the curve
   */
  static butterflyCurve(origin, scale, loops, lambda) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let t = 0.0; t < upperLimit; t += stepSize) {
      let e = (Math.exp(Math.cos(t)) - 2 * Math.cos(lambda * t) - Math.pow(Math.sin(t / 12), 5));
      let x = Math.sin(t) * e;
      let y = Math.cos(t) * e;
      points.push({
        x: x * scale + origin.x,
        y: y * scale + origin.y
      });
    }
    return points;
  }

  /**
   * Returns the points generated by a Hypocycloid curve
   * @param {object} origin - xymap with starting coordinates
   * @param {number} r      - minor circle radio
   * @param {number} R      - major circle radio
   * @param {number} loops  - number of loops to iterate
   */
  static hypocycloid(origin, scale, loops, r, R) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = (R - r) * Math.cos(th) + r * Math.cos(((R - r) / r) * th);
      let y = (R - r) * Math.sin(th) - r * Math.sin(((R - r) / r) * th);
      points.push({ x: x * scale + origin.x, y: y * scale + origin.y });
    }
    return points;
  }

  /**
   * Returns the points generated by a Rose curve.
   * The k parameter can be expressed as (n/d), being both integer values
   * @param {object} origin - xymap with starting coordinates
   * @param {number} k      - k factor of the Rose curve (n/d)
   * @param {number} loops  - number of loops to iterate
   */
  static rose(origin, scale, loops, k) {
    let points = [];
    let stepSize = 0.025;
    let upperLimit = loops * Math.PI;
    for (let th = 0.0; th < upperLimit; th += stepSize) {
      let x = Math.cos(k * th) * Math.cos(th);
      let y = Math.cos(k * th) * Math.sin(th);
      points.push({ x: x, y: y });
    }
    return points;
  }

  /**
   * Returns the points from the Rossler attractor
   * @param {object} origin - xy coordinates to center the attractor
   * @param {number} scale - scale factor
   * @param {number} loops - number of iterations
   * @param {number} a a value
   * @param {number} b b value
   * @param {number} c c value
   * @param {number} h h value
   * @return a list of xy points
   *
   *  Rossler Attractor code.
   *  http://paulbourke.net/fractals/rossler/
   */
  static rossler(origin, scale, loops, a, b, c, h) {
    function rosslerPoint(x, y, z, a, b, c) {
      let dx = -(y + z);
      let dy = x + a * y;
      let dz = b + z * (x - c);
      return {
        x: dx,
        y: dy,
        z: dz
      };
    };
    let center = {
      x: origin.x,
      y: origin.y
    }; // center in the screen
    let x = 0.1,
      y = 0.1,
      z = 0.1;
    let tmpx = 0,
      tmpy = 0,
      tmpz = 0;
    let points = [];
    for (let i = 0; i < loops; i++) {
      let dt = rosslerPoint(x, y, z, a, b, c);
      tmpx = x + h * dt.x;
      tmpy = y + h * dt.y;
      tmpz = z + h * dt.z;
      //if (Math.abs(tmpx*20 - x*20) > 5 || Math.abs(tmpy*20 - y*20) > 5)
      points.push({
        x: tmpx * scale + center.x,
        y: tmpy * scale + center.y,
        z: tmpz
      });
      x = tmpx;
      y = tmpy;
      z = tmpz;
    }
    return points;
  }

  /**
   * Returns the Lorent attractor points
   * @param {object} origin - xy coordinates
   * @param {number} scale - scale factor
   * @param {number} loops - iterations
   * @param {number} z - value
   * @param {number} a - value
   * @param {number} b - value
   * @param {number} c - value
   * @param {number} h - value
   * @return a list of xypoints
  
    Lorentz Attractor code.
    http://www.algosome.com/articles/lorenz-attractor-programming-code.html
  */
 static lorentz(origin, scale, loops, x, y, z, a, b, c, h) {
    function lorentzPoint(x, y, z, a, b, c) {
      let dx = a * (y - x);
      let dy = x * (b - z) - y;
      let dz = x * y - c * z;
      return {
        x: dx,
        y: dy,
        z: dz
      };
    };

    //var x = 0.1, y = 0.1, z = 0.1;
    let tmpx = 0,
      tmpy = 0,
      tmpz = 0;
    let points = [];
    for (let i = 0; i < loops; i++) {
      let dt = lorentzPoint(x, y, z, a, b, c);
      tmpx = x + h * dt.x;
      tmpy = y + h * dt.y;
      tmpz = z + h * dt.z;
      points.push({
        x: tmpx * scale + origin.x,
        y: tmpy * scale + origin.y,
        z: tmpz
      });
      x = tmpx;
      y = tmpy;
      z = tmpz;
    }
    return points;
  }

  /**
   * Returns the points from an attractor
   * http://struct.cc/blog/2011/08/15/strange-attractors/
   * @param {number} numPoints number of points to generate
   * @param {string} entryString initial configuration string
   * @return a list of xy points
   */
  static attractor(origin, loops, entryString) {
    // Fractal pattern and coefficients.
    let a = [];
    let points = [];

    // Parameters.
    let x = 0.1,
      y = 0.1;
    let r = 360 % entryString.length;

    // Initialize coefficients.
    for (let i = 0; i < entryString.length; i++) {
      a[i] = (entryString.charCodeAt(i) - 65 - 12) / 10;
    }
    points.push({
      x: origin.x + 50 * Math.cos(r),
      y: origin.y + 58 * Math.sin(r),
      r: 0
    });
    for (let i = 0; i < loops; i++) {
      let nx = a[0] + a[1] * x + a[2] * x * x +
        a[3] * x * y + a[4] * y + a[5] * y * y;
      let ny = a[6] + a[7] * x + a[8] * x * x +
        a[9] * x * y + a[10] * y + a[11] * y * y;
      let xvalue = (origin.x) * nx + origin.x;
      let yvalue = (origin.y) * ny + origin.y;
      //let previousPoint = res[res.length-1];
      points.push({
        x: Math.abs(xvalue),
        y: Math.abs(yvalue)
      });
      x = nx;
      y = ny;
      //r: Functions.calculateAngle (previousPoint, {x:xvalue, y:yvalue})});
    }
    return points;
  }

  /*a = -2.24, b = 0.43, c = -0.65, d = -2.43
    a = 2.01, b = -2.53, c = 1.61, d = -0.33
    a = -2, b = -2, c = -1.2, d = 2
    a = 2.01, b = -2.53, c = 1.61, d = -0.33
    a = -2, b = -2, c = -1.2, d = 2
  */
 static dejon(origin, a, b, c, d, scale = 100, loops = 10) {
    let points = []
    let xt = 1, yt = 1
    for (let i = 0; i < loops; i++) {
      let nextx = (Math.sin(a * yt) - Math.cos(b * xt))
      let nexty = (Math.sin(c * xt) - Math.cos(d * yt))
      points.push({ x: scale * xt + origin[0] + scale, y: scale * yt + origin[1] - scale })
      xt = nextx
      yt = nexty
    }
    return points
  }
}

module.exports = Parametrics
},{}],4:[function(require,module,exports){

"use strict"

class Path {

  constructor (scene, style={}) {
    this.style = style
    this.instrs = []
    this.ops = []
    this.parent = scene
    this.ctx = scene.ctx
  }

  clone(style) {
    let path = new Path(this, style || this.style)
    path.instrs = this.instrs.slice(0)
    path.ops = this.ops.slice(0)
    this.parent.children.push(path)
    return path
  }

  m(x,y) {
    let point = typeof(x) === "object" ? x : {x:x, y:y}
    this.instrs.push({instr:"m", p:point}); return this
  }

  l(x,y) {
    let point = typeof(x) === "object" ? x : {x:x, y:y}
    this.instrs.push({instr:"l", p:point}); return this
  }

  bezier(c1, c2, p2) { this.instrs.push({instr:"b", c1:c1, c2:c2, p2:p2}); return this }
  arc(p1, p2, r) { this.instrs.push({instr:"a", p1:p1, p2:p2, r:r}); return this}
  quad(c, p) { this.instrs.push({instr:"q", c:c, p:p}); return this }

  center() {
    let x = 0, y = 0, pts = 0;
    this.instrs.forEach (i => {
      switch(i.instr) {
        case "l" :
          x += i.p.x; y += i.p.y
          pts += 1
          break
        case "q":
          x += i.p.x; y += i.p.y;
          x += i.c.x; y += i.c.y;
          pts += 2
          break;
        case "b":
          x += i.c1.x; y += i.c1.y
          x += i.c2.x; y += i.c2.y
          x += i.p2.x; y += i.p2.y
          pts += 3
          break;
        case "a":
          x += i.p1.x; y += i.p1.y
          x += i.p2.x; y += i.p2.y
          pts += 2
          break;
      }
    })
    if (pts) {
      x = x / (pts)
      y = y / (pts)
    }
    return {x:x, y:y}
  }

  shadow(blur=0, color="black", alpha=1, x=5, y=5) {
    this.ctx.shadowBlur = blur
    this.ctx.shadowColor = color
    this.ctx.shadowOffsetX = x
    this.ctx.shadowOffsetY = y
    this.ctx.shadowAlpha = alpha
    return this
  }

  add(p1,p2) {
    return ({x: p1.x + p2.x, y: p1.y + p2.y})
  }

  moveTo(p) {
    let center = this.center()
    let distance = {x: p.x - center.x, y: p.y - center.y}
    this.instrs.forEach (i => {
      switch(i.instr) {
        case "m" : case "l" : case "arc":
          i.p = this.add(i.p, distance);
          break
        case "q":
          i.p = this.add(i.p, distance);
          i.c = this.add(i.c, distance); break
        case "b":
          i.c1 = this.add(i.c1, distance)
          i.c2 = this.add(i.c2, distance)
          i.p2 = this.add(i.p2, distance); break;
        case "a":
          i.p1 = this.add(i.p1, distance);
          i.p2 = this.add(i.p2, distance); break;
      }
    })
    return this
  }

  rotate(deg, p) {
    if(p) {
      this.ops.push({op:"translate", values:[p.x, p.y]})
      this.ops.push({op:"rotate", values:[deg * Math.PI/180]})
      this.ops.push({op:"translate", values:[-p.x, -p.y]})
    }
    else{
      this.ops.push({op:"rotate", values:[deg * Math.PI/180]})
    }
    return this
  }

  draw () {
    this.ops.forEach (op => {
      if (op.op === "translate") {
        this.ctx.translate(op.values[0], op.values[1])
      }
      else { // rotate
        this.ctx.rotate(op.values[0])
      }
    })
    this.ctx.beginPath()
    this.instrs.forEach (instr => {
       switch (instr.instr) {
         case "m": this.ctx.moveTo(instr.p.x, instr.p.y); break
         case "l": this.ctx.lineTo(instr.p.x, instr.p.y); break
         case "b": this.ctx.bezierCurveTo(instr.c1.x, instr.c1.y,
                                               instr.c2.x, instr.c2.y,
                                               instr.p2.x, instr.p2.y); break
         case "a": this.ctx.arcTo(instr.p1.x, instr.p1.y, instr.p2.x, instr.p2.y, instr.r); break
         case "q": this.ctx.quadraticCurveTo(instr.c.x, instr.c.y, instr.p.x, instr.p.y); break
         case "arc": this.ctx.arc(instr.p.x, instr.p.y, instr.r, instr.sa, instr.ea, instr.cw); break
       }
    })
    this.applyStyle()
   }

   applyStyle() {
     if (this.style.fill) {
       this.ctx.globalAlpha = this.style.alpha || 1
       this.ctx.fillStyle = this.style.fill
       this.ctx.fill()
     }
     if (this.style.stroke) {
       this.ctx.globalAlpha = this.style.strokeAlpha || this.style.alpha || 1
       this.ctx.strokeStyle = this.style.stroke
       this.ctx.lineWidth=this.style.strokeWidth || 1
       this.ctx.stroke()
     }
     if (this.style.shadow) {
       this.ctx.shadowColor = this.style.shadow
       this.ctx.shadowOffsetX = 10
       this.ctx.shadowOffsetY = 10
       //this.ctx.shadowBlur = this.style.shadowBlur;
     }
     if (this.style.filter) {
       this.style.filter.forEach(f => this.ctx.filter(f))
     }
     this.ctx.lineCap = this.style.lineCap || "butt"
     this.ctx.setTransform(1, 0, 0, 1, 0, 0);
   }

   fromPoints(m, n, height=10, padding=0) {
     let vector = {x: n.x - m.x, y:n.y - m.y}
     let length = Math.sqrt(vector.x * vector.x + vector.y * vector.y)
     let p0 = {x:m.x -padding, y:m.y - height/2}
     let p1 = {x:m.x + length + padding, y:m.y - height/2}
     let p2 = {x:m.x + length + padding, y:m.y + height/2}
     let p3 = {x:m.x- padding, y:m.y + height/2}
     this.m(p0).l(p1).l(p2).l(p3).l(p0)
     let xdiff = n.x - m.x
     let ydiff = n.y - m.y
     let deg = Math.atan2(ydiff, xdiff) * (180 / Math.PI)
     this.rotate(deg, m)
     return this
   }

   circle(p, r=10, sa=0, ea=Math.PI * 2, cw=true) {
     this.instrs.push({instr:"arc", p:{x:0,y:0}, r:r, sa:sa, ea:ea, cw:cw})
     this.moveTo(p)
     return this
   }

   rect(p0, w, h) {
     return this.fromPoints({x:p0.x, y:p0.y+h/2}, {x:p0.x+w, y:p0.y+h/2}, h)
   }

   line(p0, p1) {
     this.ctx.beginPath()
     this.m(p0).l(p1)
     this.applyStyle()
     return this
   }
}

module.exports = Path

},{}],5:[function(require,module,exports){

//let fs = require ("fs")
//let path = require ("path")
//let Canvas = require('canvas')
//let Image = Canvas.Image

let Brush = require ("./Brush")
let Layout = require ("./Layout")
//let Rnd = require ("./Rnd").Rnd
let Path = require ("./Path")
let Parametrics = require ("./Parametrics")

class Scene {

  constructor (params, style={}) {
    this.Brush = Brush
    this.scale = params.scale || 1
    this.width = params.width * this.scale || 1000
    this.height = params.height * this.scale || 1000
    this.canvas = document.getElementById('canvas');
    canvas.width = this.width
    canvas.height = this.height
    this.ctx = this.canvas.getContext('2d')
    this.start = Date.now()
    // if (params.seed) {
    //   console.log("Using seed: " + params.seed)
    //   this.rnd = new Rnd(params.seed)
    // }
    // else {
    //     let seed = (Math.random() * 10000).toString().substr(5, 8)
    //     console.log("Using seed: " + seed)
    //     this.rnd = new Rnd(seed)
    // }
    this.children = []
    this.drawBackground(this.width, this.height, style)
  }

  drawBackground (width, height, style) {
    this.ctx.fillStyle = style.fill || "white"
    this.ctx.fillRect(0, 0, width * this.scale , height * this.scale)
    this.ctx.fillStyle = "black"
  }

  setStyle(style) {
    this.drawBackground(this.width, this.height, style)
  }

  rint (lower, upper) { return this.rnd.int(lower, upper) }
  rand (lower, upper) { return this.rnd.random(lower, upper)}
  pick (list, ...elems) { return this.rnd.pick(list, ...elems)}

  path(style) {
    let path = new Path(this, style)
    this.children.push(path)
    return path
  }

  // Linear gradient: p0, p1, stops as [[num, color]]
  lgrad (p0, p1, colors) {
    let grad = this.ctx.createLinearGradient(0, 0, 1000, 1000)
    colors.forEach (c => { grad.addColorStop(c[0], c[1])})
    return grad
  }

  // Radial gradient
  rgrad (p0, r0, p1, r1, colors) {
    let grad = this.ctx.createRadialGradient(p0.x, p0.y, r0, p1.x, p1.y, r1)
    colors.forEach (c => { grad.addColorStop(c[0], c[1])})
    return grad
  }

  draw() {
    this.children.forEach(c => c.draw())
  }

  saveTo (fileName) {
    this.canvas.createPNGStream().pipe(fs.createWriteStream(fileName))
    console.log("Save to " + fileName + " (" + (Date.now()-this.start)/1000 + " secs)")
  }
}

module.exports =  { Scene, Layout, Path, Parametrics}

},{"./Brush":1,"./Layout":2,"./Parametrics":3,"./Path":4}]},{},[5])(5)
});
